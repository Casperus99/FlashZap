---
description: When writing a test that require database
globs: 
alwaysApply: false
---
# Mocking the Database

For tests that interact with the database, it is crucial to isolate the tests from the actual database to ensure they are fast, reliable, and do not have side effects.

## Strategy 1: In-Memory SQLite Database

When you need to test the interaction between your code and a database (e.g., to verify that a commit to a session correctly persists data), you should use the `test_db_session` fixture. This fixture, defined in `tests/conftest.py`, provides a fresh, in-memory SQLite database for each test function.

**Example Usage**

To use the in-memory database, simply include `test_db_session` as an argument in your test function. You can then use it as you would a regular SQLAlchemy session.

```python
from flash_zap.models.card import Card
from flash_zap.services.import_service import _save_cards_to_db

def test_save_cards_to_database(test_db_session):
    """
    GIVEN: A list of dictionaries with valid card data.
    WHEN: The _save_cards_to_db function is called.
    THEN: The new cards are correctly saved to the database.
    """
    # GIVEN
    cards_data = [
        {"front": "Q1", "back": "A1"},
        {"front": "Q2", "back": "A2"},
    ]
    session = test_db_session

    # WHEN
    _save_cards_to_db(cards_data, session)

    # THEN
    saved_cards = session.query(Card).all()
    assert len(saved_cards) == 2
    assert saved_cards[0].front == "Q1"
    assert saved_cards[0].back == "A1"
    assert saved_cards[1].front == "Q2"
    assert saved_cards[1].back == "A2"

```