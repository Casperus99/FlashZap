---
description: When writing tests that require database
globs: 
alwaysApply: false
---
## Mocking the Database

For backend tests that interact with the database, it is crucial to isolate the tests from the actual database to ensure they are fast, reliable, and do not have side effects. In our project, we use two primary strategies for this, depending on the testing needs.

### Strategy 1: In-Memory SQLite Database for Integration Tests

When you need to test the interaction between your code and a database (e.g., to verify that a commit to a session correctly persists data), you should use the `test_db_session` fixture. This fixture, defined in `tests/conftest.py`, provides a fresh, in-memory SQLite database for each test function.

**When to use it:**

-   Testing database queries and transactions.
-   Verifying that data is correctly added, updated, or deleted.
-   Ensuring that relationships between models are working as expected.

**Example Usage:**

To use the in-memory database, simply include `test_db_session` as an argument in your test function. You can then use it as you would a regular SQLAlchemy session.

```python
from flash_zap.models.card import Card
from flash_zap.core.card_manager import update_card_front

def test_update_card_front_with_fixture(test_db_session):
    # Arrange: Create and add a card to the in-memory database
    card = Card(front="Original", back="Back")
    test_db_session.add(card)
    test_db_session.commit()

    # Act: Call the function that interacts with the database
    updated_card = update_card_front(test_db_session, card.id, "New Front")
    test_db_session.refresh(card)

    # Assert: Verify the change was made correctly
    assert updated_card.front == "New Front"
```

### Strategy 2: Mocking with `unittest.mock` for Unit Tests

When you want to test the logic of a single function in isolation, without involving the database at all, you should use `unittest.mock.Mock`. This allows you to simulate the database session and control the return values of its methods.

**When to use it:**

-   Testing business logic that is independent of the database.
-   Isolating a function from its dependencies to test it in a controlled environment.
-   Avoiding the overhead of setting up a database when it is not needed.

**Example Usage:**

You can create a mock session and configure its methods to return specific values, allowing you to test how your function behaves under different conditions.

```python
from unittest.mock import Mock
from flash_zap.core.card_manager import get_card_by_id
from flash_zap.models.card import Card

def test_get_card_by_id_with_mock():
    # Arrange: Create a mock session and a card
    mock_session = Mock()
    expected_card = Card(id=1, front="Front", back="Back")

    # Configure the mock to simulate the database call
    mock_session.query.return_value.filter_by.return_value.first.return_value = expected_card

    # Act: Call the function with the mock session
    card = get_card_by_id(mock_session, 1)

    # Assert: Check that the function behaved as expected
    mock_session.query.assert_called_once_with(Card)
    assert card == expected_card

```