---
description: For writing tests regarding new backend
globs: 
alwaysApply: false
---
# TDD Guidelines for Backend API Testing: The RED-GREEN-REFACTOR Workflow

This document mandates a strict Test-Driven Development (TDD) workflow for building the backend API. Every feature must be developed following the **Red-Green-Refactor** cycle. These tests focus on the API layer (FastAPI routes) in isolation, using mocks to separate it from the business logic layer.

## Core Principle: The Red-Green-Refactor Cycle

This is the only permitted workflow for developing backend endpoints.

1.  **ðŸ”´ RED â€” Write a Failing Test**: Before writing any implementation code, write a test that defines a small piece of desired functionality. This test **must fail** because the feature doesn't exist yet. This proves the test is valid.
2.  **ðŸŸ¢ GREEN â€” Make the Test Pass**: Write the **absolute minimum** amount of code required to make the failing test pass. Do not add extra features or refactor at this stage. The goal is simply to get a passing test bar.
3.  **ðŸ”µ REFACTOR â€” Clean Up the Code**: With a passing test as your safety net, improve the code you just wrote. Enhance readability, remove duplication, and improve performance without changing its external behavior. Rerun tests to ensure they still pass.

Repeat this cycle for the next small piece of functionality.

## Technology Stack

*   **Test Runner**: `pytest`
*   **HTTP Client**: `fastapi.testclient.TestClient`
*   **Mocking Library**: `unittest.mock` (especially `patch`)

---

## Applying the Cycle: A Step-by-Step Example

Let's build the `GET /cards` endpoint strictly following the TDD cycle.

### Feature: Display all cards.

#### Cycle 1: Ensure the endpoint exists and returns success.

*   **ðŸ”´ RED**: Write a test that expects a `200 OK` response from `GET /cards`.
    ```python
    # in tests/web/test_api_views.py
    def test_get_cards_returns_200_ok(client):
        response = client.get("/cards")
        assert response.status_code == 200
    ```
    **Result**: This fails with a `404 Not Found` because the route does not exist.

*   **ðŸŸ¢ GREEN**: Write the minimum code to make it pass.
    ```python
    # in src/flash_zap/web/routes.py
    from fastapi import APIRouter
    router = APIRouter()

    @router.get("/cards")
    def get_cards():
        return [] # Return anything to satisfy the endpoint contract
    ```
    **Result**: The test now passes. The endpoint exists.

*   **ðŸ”µ REFACTOR**: The code is minimal and clean. No refactoring is needed yet.

#### Cycle 2: Ensure the endpoint calls the correct service.

*   **ðŸ”´ RED**: Write a test to verify that `card_manager.get_all_cards()` is called. We **mock** the service layer to isolate the API layer.
    ```python
    # in tests/web/test_api_views.py
    from unittest.mock import patch

    @patch("src.flash_zap.web.routes.card_manager")
    def test_get_cards_calls_card_manager(mock_card_manager, client):
        client.get("/cards")
        mock_card_manager.get_all_cards.assert_called_once()
    ```
    **Result**: This fails with `AssertionError: Expected 'get_all_cards' to be called once. Called 0 times.`

*   **ðŸŸ¢ GREEN**: Update the endpoint to call the service.
    ```python
    # in src/flash_zap/web/routes.py
    # ... imports
    from flash_zap.core import card_manager

    @router.get("/cards")
    def get_cards():
        card_manager.get_all_cards()
        # The template rendering part is not yet tested, so we keep it minimal.
        return []
    ```
    **Result**: The test now passes.

*   **ðŸ”µ REFACTOR**: The code is still simple. No refactoring needed.

#### Cycle 3: Ensure the endpoint passes data to the template.

*   **ðŸ”´ RED**: Write a test to ensure that the data returned by the service is passed to the template context.
    ```python
    # in tests/web/test_api_views.py
    from unittest.mock import patch, MagicMock

    @patch("src/flash_zap.web.routes.templates") # Mock the templates object
    @patch("src.flash_zap.web.routes.card_manager")
    def test_get_cards_passes_cards_to_template(mock_card_manager, mock_templates, client):
        # Arrange: Make the mocked manager return some fake data
        fake_cards = [MagicMock(), MagicMock()]
        mock_card_manager.get_all_cards.return_value = fake_cards

        # Act
        client.get("/cards")

        # Assert
        mock_templates.TemplateResponse.assert_called_once()
        call_args = mock_templates.TemplateResponse.call_args[0]
        assert call_args[0] == "browse_view.html" # Check template name
        assert "cards" in call_args[1]["request"].context
        assert call_args[1]["request"].context["cards"] == fake_cards
    ```
    **Result**: This will fail in multiple ways because we are not yet calling `TemplateResponse` correctly.

*   **ðŸŸ¢ GREEN**: Implement the template rendering logic.
    ```python
    # in src/flash_zap/web/routes.py
    # ... imports
    from fastapi import Request
    from flash_zap.web.app import templates

    @router.get("/cards")
    def get_cards(request: Request):
        cards = card_manager.get_all_cards()
        return templates.TemplateResponse("browse_view.html", {"request": request, "cards": cards})
    ```
    **Result**: The test now passes.

*   **ðŸ”µ REFACTOR**: The code is now functional. We can review for clarity and style. The imports might need organizing. The logic is clean and directly follows the requirements.


This strict, iterative process ensures that every line of implementation code is directly justified by a test. 

## Mocking the Database

For backend tests that interact with the database, it is crucial to isolate the tests from the actual database to ensure they are fast, reliable, and do not have side effects. In our project, we use two primary strategies for this, depending on the testing needs.

### Strategy 1: In-Memory SQLite Database for Integration Tests

When you need to test the interaction between your code and a database (e.g., to verify that a commit to a session correctly persists data), you should use the `test_db_session` fixture. This fixture, defined in `tests/conftest.py`, provides a fresh, in-memory SQLite database for each test function.

**When to use it:**

-   Testing database queries and transactions.
-   Verifying that data is correctly added, updated, or deleted.
-   Ensuring that relationships between models are working as expected.

**Example Usage:**

To use the in-memory database, simply include `test_db_session` as an argument in your test function. You can then use it as you would a regular SQLAlchemy session.

```python
from flash_zap.models.card import Card
from flash_zap.core.card_manager import update_card_front

def test_update_card_front_with_fixture(test_db_session):
    # Arrange: Create and add a card to the in-memory database
    card = Card(front="Original", back="Back")
    test_db_session.add(card)
    test_db_session.commit()

    # Act: Call the function that interacts with the database
    updated_card = update_card_front(test_db_session, card.id, "New Front")
    test_db_session.refresh(card)

    # Assert: Verify the change was made correctly
    assert updated_card.front == "New Front"
```

### Strategy 2: Mocking with `unittest.mock` for Unit Tests

When you want to test the logic of a single function in isolation, without involving the database at all, you should use `unittest.mock.Mock`. This allows you to simulate the database session and control the return values of its methods.

**When to use it:**

-   Testing business logic that is independent of the database.
-   Isolating a function from its dependencies to test it in a controlled environment.
-   Avoiding the overhead of setting up a database when it is not needed.

**Example Usage:**

You can create a mock session and configure its methods to return specific values, allowing you to test how your function behaves under different conditions.

```python
from unittest.mock import Mock
from flash_zap.core.card_manager import get_card_by_id
from flash_zap.models.card import Card

def test_get_card_by_id_with_mock():
    # Arrange: Create a mock session and a card
    mock_session = Mock()
    expected_card = Card(id=1, front="Front", back="Back")

    # Configure the mock to simulate the database call
    mock_session.query.return_value.filter_by.return_value.first.return_value = expected_card

    # Act: Call the function with the mock session
    card = get_card_by_id(mock_session, 1)

    # Assert: Check that the function behaved as expected
    mock_session.query.assert_called_once_with(Card)
    assert card == expected_card
```



By choosing the appropriate strategy, you can write backend tests that are both effective and maintainable. Remember to prefer unit tests with mocks for speed and isolation, and use the in-memory database for testing database-specific interactions. 